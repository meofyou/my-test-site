<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chrome Dino Clone</title>
    <style>
      :root {
        --bg: #f7f7f7;
        --ink: #535353;
        --line: #c9c9c9;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: var(--bg);
        color: var(--ink);
        font-family: "Segoe UI", Tahoma, sans-serif;
      }

      .game-wrap {
        width: min(920px, 96vw);
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        border-bottom: 1px solid var(--line);
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        background: #fff;
      }

      .help {
        margin-top: 10px;
        font-size: 13px;
        text-align: center;
        color: #7a7a7a;
      }
    </style>
  </head>
  <body>
    <div class="game-wrap">
      <canvas id="game" width="920" height="220" aria-label="Chrome Dino Game"></canvas>
      <div class="help">`Space` / `↑`: 점프, `↓`: 숙이기, 게임 오버 시 `Space`로 재시작</div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;
      const GROUND_Y = 182;
      const GRAVITY = 0.56;
      const JUMP_POWER = 11.6;
      const BASE_SPEED = 6.2;

      const state = {
        running: false,
        gameOver: false,
        score: 0,
        hi: Number(localStorage.getItem("dino-hi") || 0),
        speed: BASE_SPEED,
        tick: 0,
        blinkTick: 0,
      };

      const input = {
        up: false,
        down: false,
      };

      const dino = {
        x: 64,
        y: GROUND_Y - 44,
        width: 44,
        height: 44,
        duckHeight: 28,
        vy: 0,
        grounded: true,
        ducking: false,
        frame: 0,
      };

      const obstacles = [];
      const clouds = [];
      const groundSegments = [];

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function addCloud() {
        clouds.push({
          x: WIDTH + rand(10, 260),
          y: rand(24, 88),
          w: rand(42, 68),
          h: rand(14, 22),
          speed: rand(0.8, 1.9),
        });
      }

      function addGroundSegment(startX) {
        groundSegments.push({
          x: startX,
          len: rand(30, 110),
        });
      }

      function addObstacle() {
        const isBird = state.score > 400 && Math.random() < 0.23;
        if (isBird) {
          obstacles.push({
            type: "bird",
            x: WIDTH + rand(30, 120),
            y: GROUND_Y - (Math.random() < 0.5 ? 34 : 64),
            width: 46,
            height: 30,
            wing: 0,
          });
          return;
        }

        const kind = Math.random() < 0.55 ? "small" : "big";
        if (kind === "small") {
          obstacles.push({
            type: "cactus",
            x: WIDTH + rand(30, 120),
            y: GROUND_Y - 38,
            width: 26,
            height: 38,
          });
          return;
        }

        obstacles.push({
          type: "cactus",
          x: WIDTH + rand(30, 120),
          y: GROUND_Y - 54,
          width: 34,
          height: 54,
        });
      }

      function resetWorld() {
        obstacles.length = 0;
        clouds.length = 0;
        groundSegments.length = 0;
        for (let i = 0; i < 6; i += 1) addCloud();
        let gx = 0;
        while (gx < WIDTH + 120) {
          addGroundSegment(gx);
          gx += rand(38, 140);
        }
      }

      function restart() {
        state.running = false;
        state.gameOver = false;
        state.score = 0;
        state.speed = BASE_SPEED;
        state.tick = 0;
        state.blinkTick = 0;
        dino.y = GROUND_Y - 44;
        dino.vy = 0;
        dino.grounded = true;
        dino.ducking = false;
        resetWorld();
      }

      function beginGame() {
        if (state.gameOver) {
          restart();
        }
        state.running = true;
      }

      function jump() {
        if (!dino.grounded) return;
        dino.vy = -JUMP_POWER;
        dino.grounded = false;
      }

      function updateDino() {
        dino.ducking = input.down && dino.grounded;
        dino.height = dino.ducking ? dino.duckHeight : 44;

        if (!dino.grounded) {
          dino.vy += GRAVITY;
          dino.y += dino.vy;
          const groundY = GROUND_Y - dino.height;
          if (dino.y >= groundY) {
            dino.y = groundY;
            dino.vy = 0;
            dino.grounded = true;
          }
        } else {
          dino.y = GROUND_Y - dino.height;
        }

        if (state.running && !state.gameOver) {
          dino.frame = (dino.frame + 1) % 12;
        }
      }

      function updateClouds() {
        for (const c of clouds) {
          c.x -= c.speed;
        }
        if (clouds.length && clouds[0].x + clouds[0].w < -20) {
          clouds.shift();
          addCloud();
        }
      }

      function updateGround() {
        for (const g of groundSegments) {
          g.x -= state.speed;
        }
        while (groundSegments.length && groundSegments[0].x + groundSegments[0].len < -10) {
          groundSegments.shift();
        }
        if (!groundSegments.length || groundSegments[groundSegments.length - 1].x < WIDTH - 30) {
          addGroundSegment(WIDTH + rand(12, 80));
        }
      }

      function updateObstacles() {
        if (!state.running || state.gameOver) return;

        for (const o of obstacles) {
          o.x -= state.speed;
          if (o.type === "bird") {
            o.wing = (o.wing + 1) % 18;
          }
        }
        while (obstacles.length && obstacles[0].x + obstacles[0].width < -20) {
          obstacles.shift();
        }

        const last = obstacles[obstacles.length - 1];
        if (!last || WIDTH - last.x > rand(210, 370) - state.speed * 8) {
          addObstacle();
        }
      }

      function getDinoHitbox() {
        const padX = dino.ducking ? 6 : 8;
        const padY = dino.ducking ? 5 : 4;
        return {
          x: dino.x + padX,
          y: dino.y + padY,
          w: dino.width - padX * 2,
          h: dino.height - padY * 2,
        };
      }

      function getObstacleHitbox(o) {
        if (o.type === "bird") {
          return { x: o.x + 4, y: o.y + 5, w: o.width - 8, h: o.height - 10 };
        }
        return { x: o.x + 3, y: o.y + 2, w: o.width - 6, h: o.height - 4 };
      }

      function intersects(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      function checkCollision() {
        const db = getDinoHitbox();
        for (const o of obstacles) {
          if (intersects(db, getObstacleHitbox(o))) {
            state.gameOver = true;
            state.running = false;
            state.hi = Math.max(state.hi, Math.floor(state.score));
            localStorage.setItem("dino-hi", String(state.hi));
            return;
          }
        }
      }

      function updateScore() {
        if (!state.running || state.gameOver) return;
        state.score += 0.1;
        state.speed = BASE_SPEED + Math.min(6, Math.floor(state.score) / 180);
      }

      function drawCloud(c) {
        ctx.fillStyle = "#d6d6d6";
        ctx.fillRect(c.x, c.y + 8, c.w, c.h - 8);
        ctx.fillRect(c.x + 8, c.y, c.w * 0.45, c.h * 0.7);
        ctx.fillRect(c.x + c.w * 0.42, c.y + 2, c.w * 0.46, c.h * 0.8);
      }

      function drawGround() {
        ctx.strokeStyle = "#9e9e9e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y + 0.5);
        ctx.lineTo(WIDTH, GROUND_Y + 0.5);
        ctx.stroke();

        ctx.fillStyle = "#bdbdbd";
        for (const g of groundSegments) {
          ctx.fillRect(g.x, GROUND_Y + 6, g.len, 2);
        }
      }

      function drawDino() {
        const runAlt = dino.frame < 6;
        const x = dino.x;
        const y = dino.y;
        const h = dino.height;
        ctx.fillStyle = "#535353";

        if (dino.ducking) {
          ctx.fillRect(x + 2, y + 8, 34, 16);
          ctx.fillRect(x + 28, y + 2, 12, 14);
          ctx.fillRect(x + 34, y + 5, 10, 8);
          ctx.fillRect(x + 8, y + 22, 8, 6);
          ctx.fillRect(x + (runAlt ? 20 : 24), y + 22, 8, 6);
        } else {
          ctx.fillRect(x + 8, y + 4, 20, h - 8);
          ctx.fillRect(x + 24, y, 16, 16);
          ctx.fillRect(x + 34, y + 4, 10, 8);
          ctx.fillRect(x + 12, y + h - 6, 8, 6);
          ctx.fillRect(x + (runAlt ? 24 : 20), y + h - 6, 8, 6);
          ctx.fillStyle = "#f7f7f7";
          ctx.fillRect(x + 32, y + 4, 3, 3);
          ctx.fillStyle = "#535353";
        }
      }

      function drawCactus(o) {
        ctx.fillStyle = "#535353";
        ctx.fillRect(o.x + 6, o.y, o.width - 12, o.height);
        ctx.fillRect(o.x, o.y + 12, 8, 12);
        ctx.fillRect(o.x + o.width - 8, o.y + 18, 8, 14);
      }

      function drawBird(o) {
        const wingUp = o.wing < 9;
        ctx.fillStyle = "#535353";
        ctx.fillRect(o.x + 10, o.y + 10, 26, 10);
        ctx.fillRect(o.x + 34, o.y + 8, 10, 8);
        ctx.fillRect(o.x + 2, o.y + (wingUp ? 6 : 12), 10, wingUp ? 6 : 12);
        ctx.fillRect(o.x + 20, o.y + (wingUp ? 2 : 14), 10, wingUp ? 6 : 6);
      }

      function drawObstacles() {
        for (const o of obstacles) {
          if (o.type === "bird") drawBird(o);
          else drawCactus(o);
        }
      }

      function drawScore() {
        const scoreText = String(Math.floor(state.score)).padStart(5, "0");
        const hiText = String(Math.floor(state.hi)).padStart(5, "0");
        ctx.fillStyle = "#6f6f6f";
        ctx.font = "20px monospace";
        ctx.textAlign = "right";
        ctx.fillText(`HI ${hiText}  ${scoreText}`, WIDTH - 18, 28);
      }

      function drawStartPrompt() {
        if (state.running || state.gameOver) return;
        state.blinkTick = (state.blinkTick + 1) % 80;
        if (state.blinkTick > 40) return;
        ctx.fillStyle = "#8a8a8a";
        ctx.font = "18px monospace";
        ctx.textAlign = "center";
        ctx.fillText("PRESS SPACE TO START", WIDTH / 2, 82);
      }

      function drawGameOver() {
        if (!state.gameOver) return;
        ctx.fillStyle = "#535353";
        ctx.font = "28px monospace";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", WIDTH / 2, 78);

        ctx.font = "16px monospace";
        ctx.fillText("SPACE TO RESTART", WIDTH / 2, 106);

        const bx = WIDTH / 2 - 20;
        const by = 120;
        ctx.strokeStyle = "#777";
        ctx.strokeRect(bx, by, 40, 24);
        ctx.beginPath();
        ctx.moveTo(bx + 20, by + 5);
        ctx.lineTo(bx + 20, by + 19);
        ctx.lineTo(bx + 9, by + 12);
        ctx.stroke();
      }

      function render() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        for (const c of clouds) drawCloud(c);
        drawGround();
        drawDino();
        drawObstacles();
        drawScore();
        drawStartPrompt();
        drawGameOver();
      }

      function update() {
        state.tick += 1;
        updateClouds();
        updateDino();
        updateGround();
        updateObstacles();
        checkCollision();
        updateScore();
      }

      function loop() {
        update();
        render();
        requestAnimationFrame(loop);
      }

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          if (state.gameOver || !state.running) beginGame();
          jump();
          input.up = true;
        }
        if (e.code === "ArrowDown") {
          e.preventDefault();
          input.down = true;
          if (!state.running && !state.gameOver) beginGame();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") input.up = false;
        if (e.code === "ArrowDown") input.down = false;
      });

      restart();
      loop();
    </script>
  </body>
</html>
