<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>FreeCell v1.2.0</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Spectral:wght@400;600&display=swap");

      :root {
        --bg-1: #08111f;
        --bg-2: #0d2137;
        --bg-3: #18344a;
        --card: #f8f2ea;
        --card-ink: #111217;
        --accent: #f0b35a;
        --accent-2: #6bd1b6;
        --outline: rgba(255, 255, 255, 0.22);
        --shadow: rgba(4, 10, 24, 0.48);
        --card-w: 96px;
        --card-h: 132px;
        --col-w: 116px;
        --stack-gap: 34px;
        --gutter: 14px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        color: #edf3fb;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        background: radial-gradient(circle at 10% 20%, rgba(107, 209, 182, 0.18), transparent 40%),
          radial-gradient(circle at 80% 0%, rgba(240, 179, 90, 0.2), transparent 35%),
          linear-gradient(160deg, var(--bg-1), var(--bg-2) 45%, var(--bg-3));
      }

      .app {
        max-width: 1180px;
        margin: 0 auto;
        padding: 32px 20px 48px;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 24px;
      }

      .title {
        display: grid;
        gap: 6px;
      }

      .title h1 {
        margin: 0;
        font-size: clamp(28px, 4vw, 44px);
        letter-spacing: -0.02em;
      }

      .title p {
        margin: 0;
        font-family: "Spectral", "Georgia", serif;
        font-size: 15px;
        opacity: 0.86;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      button {
        appearance: none;
        border: 1px solid var(--outline);
        background: rgba(255, 255, 255, 0.09);
        color: inherit;
        padding: 10px 16px;
        border-radius: 999px;
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.15s ease, background 0.2s ease, border 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.17);
        border-color: rgba(255, 255, 255, 0.35);
      }

      .status {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        margin-bottom: 20px;
      }

      .status-card {
        padding: 14px 16px;
        border-radius: 14px;
        background: rgba(8, 16, 30, 0.66);
        border: 1px solid var(--outline);
        box-shadow: 0 10px 30px var(--shadow);
        font-size: 13px;
        display: grid;
        gap: 6px;
      }

      .status-card span {
        font-size: 18px;
        font-weight: 700;
      }

      .board {
        display: grid;
        gap: 18px;
        overflow-x: auto;
        padding: 0 0 8px;
      }

      .top-row {
        display: grid;
        grid-template-columns: repeat(4, minmax(var(--col-w), 1fr)) 20px repeat(4, minmax(var(--col-w), 1fr));
        gap: var(--gutter);
        align-items: start;
        min-width: calc(8 * var(--col-w) + 7 * var(--gutter) + 20px);
      }

      .separator {
        height: 60px;
      }

      .cell,
      .foundation {
        min-height: calc(var(--card-h) + 18px);
        min-width: var(--col-w);
        border-radius: 14px;
        border: 1px dashed rgba(255, 255, 255, 0.28);
        background: rgba(13, 22, 38, 0.6);
        display: grid;
        place-items: center;
        position: relative;
        padding: 9px;
        transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .foundation {
        border-style: solid;
        background: rgba(240, 179, 90, 0.12);
      }

      .cell-label {
        font-size: 11px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        opacity: 0.62;
        position: absolute;
        top: 8px;
        left: 12px;
      }

      .tableau {
        display: grid;
        grid-template-columns: repeat(8, minmax(var(--col-w), 1fr));
        gap: var(--gutter);
        min-width: calc(8 * var(--col-w) + 7 * var(--gutter));
      }

      .column {
        min-height: 460px;
        min-width: var(--col-w);
        border-radius: 16px;
        border: 1px dashed rgba(255, 255, 255, 0.2);
        padding: 12px 8px 16px;
        background: rgba(10, 16, 30, 0.6);
        position: relative;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      .card {
        width: var(--card-w);
        height: var(--card-h);
        border-radius: 12px;
        background: var(--card);
        color: var(--card-ink);
        box-shadow: 0 12px 26px rgba(5, 10, 20, 0.34);
        border: 2px solid rgba(8, 12, 20, 0.12);
        transition: transform 0.15s ease, border 0.2s ease, box-shadow 0.2s ease;
        cursor: grab;
        display: grid;
        grid-template-rows: auto 1fr auto;
        padding: 9px 10px;
        position: relative;
        z-index: 1;
        user-select: none;
      }

      .tableau-card {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }

      .card.red {
        color: #bf2d35;
      }

      .card.black {
        color: #151a25;
      }

      .card .corner {
        font-size: 18px;
        line-height: 1;
        font-weight: 700;
        display: grid;
        justify-items: start;
        gap: 1px;
      }

      .card .corner .small-suit {
        font-size: 16px;
      }

      .card .corner.bottom {
        justify-self: end;
        transform: rotate(180deg);
      }

      .card .center {
        display: grid;
        place-items: center;
      }

      .card .pips {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 2px 8px;
        width: 100%;
        justify-items: center;
      }

      .card .pip {
        font-size: 19px;
        line-height: 1;
      }

      .card .pips[data-count="1"] {
        grid-template-columns: 1fr;
      }

      .card .pips[data-count="3"] .pip:last-child,
      .card .pips[data-count="5"] .pip:last-child,
      .card .pips[data-count="7"] .pip:last-child,
      .card .pips[data-count="9"] .pip:last-child {
        grid-column: 1 / -1;
      }

      .card .face-rank {
        font-size: 38px;
        font-weight: 700;
        line-height: 1;
      }

      .card .face-suit {
        font-size: 22px;
        margin-top: 4px;
      }

      .card.selected {
        border-color: var(--accent);
        box-shadow: 0 14px 28px rgba(240, 179, 90, 0.3);
      }

      .tableau-card.selected {
        transform: translate(-50%, -4px);
      }

      .card.selected:not(.tableau-card) {
        transform: translateY(-4px);
      }

      .card.dragging {
        opacity: 0.65;
        cursor: grabbing;
      }

      .drop-ready {
        outline: 2px solid rgba(240, 179, 90, 0.68);
        outline-offset: -4px;
        box-shadow: 0 12px 30px rgba(240, 179, 90, 0.2);
      }

      .empty-msg {
        font-size: 12px;
        opacity: 0.64;
        text-align: center;
        padding: 10px;
      }

      .rules {
        margin-top: 22px;
        padding: 16px 18px;
        border-radius: 14px;
        border: 1px solid var(--outline);
        background: rgba(12, 20, 34, 0.64);
        font-size: 13px;
        line-height: 1.6;
      }

      .rules b {
        color: var(--accent);
      }

      @media (max-width: 900px) {
        :root {
          --card-w: 86px;
          --card-h: 120px;
          --col-w: 104px;
          --stack-gap: 30px;
        }

        .top-row {
          grid-template-columns: repeat(4, minmax(var(--col-w), 1fr));
        }

        .separator {
          display: none;
        }

        .tableau {
          grid-template-columns: repeat(4, minmax(var(--col-w), 1fr));
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div class="title">
          <h1>FreeCell v1.2.0</h1>
          <p>카드를 드래그하거나 클릭해서 이동하세요. 더블클릭하면 가능한 경우 Foundation으로 자동 이동합니다.</p>
        </div>
        <div class="controls">
          <button id="newGameBtn">새 게임</button>
          <button id="undoBtn">되돌리기</button>
          <button id="autoBtn">자동 이동</button>
        </div>
      </header>

      <section class="status">
        <div class="status-card">
          <div>이동 횟수</div>
          <span id="moveCount">0</span>
        </div>
        <div class="status-card">
          <div>남은 Free Cell</div>
          <span id="freeCount">4 / 4</span>
        </div>
        <div class="status-card">
          <div>남은 카드</div>
          <span id="remainingCount">52</span>
        </div>
      </section>

      <div class="board">
        <div class="top-row" id="topRow"></div>
        <div class="tableau" id="tableau"></div>
      </div>

      <div class="rules">
        <b>FreeCell 규칙 요약</b> - 모든 카드를 4개의 <b>Foundation</b>에 무늬별 A부터 K 순서로 쌓으면 승리입니다.
        <br />
        <b>Tableau</b>에서는 색이 번갈아야 하고 숫자는 내림차순으로만 내려놓을 수 있습니다.
        <b>Free Cell</b>은 임시 보관 공간이며, 빈 칸 수에 따라 한 번에 이동 가능한 카드 수가 달라집니다.
      </div>
    </div>

    <script>
      const VERSION = "1.2.0";
      const suits = [
        { name: "spades", symbol: "♠", color: "black" },
        { name: "hearts", symbol: "♥", color: "red" },
        { name: "clubs", symbol: "♣", color: "black" },
        { name: "diamonds", symbol: "♦", color: "red" },
      ];
      const ranks = [
        { name: "A", value: 1 },
        { name: "2", value: 2 },
        { name: "3", value: 3 },
        { name: "4", value: 4 },
        { name: "5", value: 5 },
        { name: "6", value: 6 },
        { name: "7", value: 7 },
        { name: "8", value: 8 },
        { name: "9", value: 9 },
        { name: "10", value: 10 },
        { name: "J", value: 11 },
        { name: "Q", value: 12 },
        { name: "K", value: 13 },
      ];

      const state = {
        freeCells: Array(4).fill(null),
        foundations: Array(4).fill(null),
        tableau: Array.from({ length: 8 }, () => []),
        moveCount: 0,
        history: [],
        selection: null,
      };
      let dragSource = null;

      const topRow = document.getElementById("topRow");
      const tableauEl = document.getElementById("tableau");
      const moveCountEl = document.getElementById("moveCount");
      const freeCountEl = document.getElementById("freeCount");
      const remainingCountEl = document.getElementById("remainingCount");
      const newGameBtn = document.getElementById("newGameBtn");
      const undoBtn = document.getElementById("undoBtn");
      const autoBtn = document.getElementById("autoBtn");

      function createDeck() {
        const deck = [];
        suits.forEach((suit) => {
          ranks.forEach((rank) => {
            deck.push({
              suit: suit.name,
              symbol: suit.symbol,
              color: suit.color,
              rank: rank.name,
              value: rank.value,
            });
          });
        });
        return deck;
      }

      function shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      }

      function deal() {
        state.tableau = Array.from({ length: 8 }, () => []);
        const deck = shuffle(createDeck());
        deck.forEach((card, index) => {
          state.tableau[index % 8].push(card);
        });
      }

      function snapshot() {
        return JSON.parse(
          JSON.stringify({
            freeCells: state.freeCells,
            foundations: state.foundations,
            tableau: state.tableau,
            moveCount: state.moveCount,
          })
        );
      }

      function restore(snap) {
        state.freeCells = snap.freeCells;
        state.foundations = snap.foundations;
        state.tableau = snap.tableau;
        state.moveCount = snap.moveCount;
      }

      function pushHistory() {
        state.history.push(snapshot());
        if (state.history.length > 200) {
          state.history.shift();
        }
      }

      function isOppositeColor(cardA, cardB) {
        return cardA.color !== cardB.color;
      }

      function canStackOnTableau(card, targetCard) {
        if (!targetCard) {
          return true;
        }
        return isOppositeColor(card, targetCard) && card.value + 1 === targetCard.value;
      }

      function canMoveToFoundation(card, foundationIndex) {
        const top = state.foundations[foundationIndex];
        if (!top) {
          return card.value === 1;
        }
        return top.suit === card.suit && card.value === top.value + 1;
      }

      function getMaxMovable() {
        const free = state.freeCells.filter((cell) => !cell).length;
        const emptyColumns = state.tableau.filter((col) => col.length === 0).length;
        return (free + 1) * Math.pow(2, emptyColumns);
      }

      function getTableauStack(columnIndex, cardIndex) {
        const column = state.tableau[columnIndex];
        const stack = column.slice(cardIndex);
        for (let i = 0; i < stack.length - 1; i += 1) {
          if (!canStackOnTableau(stack[i], stack[i + 1])) {
            return null;
          }
        }
        return stack;
      }

      function moveStackToTableau(source, targetColumn) {
        const stack = getTableauStack(source.column, source.cardIndex);
        if (!stack) return false;
        if (stack.length > getMaxMovable()) return false;

        const targetCol = state.tableau[targetColumn];
        const targetTop = targetCol[targetCol.length - 1];
        if (!canStackOnTableau(stack[0], targetTop)) return false;

        pushHistory();
        state.tableau[targetColumn] = targetCol.concat(stack);
        state.tableau[source.column] = state.tableau[source.column].slice(0, source.cardIndex);
        state.moveCount += 1;
        return true;
      }

      function removeCardFromSource(source) {
        if (source.type === "free") {
          state.freeCells[source.index] = null;
        } else if (source.type === "foundation") {
          state.foundations[source.index] = null;
        } else if (source.type === "tableau") {
          state.tableau[source.column].pop();
        }
      }

      function moveSingleCard(source, target) {
        const card = source.card;
        if (!card) return false;

        if (source.type === "tableau") {
          const col = state.tableau[source.column];
          if (col[col.length - 1] !== card) return false;
        }

        if (target.type === "foundation") {
          if (!canMoveToFoundation(card, target.index)) return false;
          pushHistory();
          state.foundations[target.index] = card;
          removeCardFromSource(source);
          state.moveCount += 1;
          return true;
        }

        if (target.type === "free") {
          if (state.freeCells[target.index]) return false;
          pushHistory();
          state.freeCells[target.index] = card;
          removeCardFromSource(source);
          state.moveCount += 1;
          return true;
        }

        if (target.type === "tableau") {
          const col = state.tableau[target.index];
          const top = col[col.length - 1];
          if (!canStackOnTableau(card, top)) return false;
          pushHistory();
          state.tableau[target.index].push(card);
          removeCardFromSource(source);
          state.moveCount += 1;
          return true;
        }

        return false;
      }

      function autoMoveOnce() {
        let moved = false;

        state.tableau.forEach((col, colIndex) => {
          if (col.length === 0) return;
          const card = col[col.length - 1];
          const index = suits.findIndex((s) => s.name === card.suit);
          if (canMoveToFoundation(card, index)) {
            pushHistory();
            state.foundations[index] = card;
            state.tableau[colIndex].pop();
            state.moveCount += 1;
            moved = true;
          }
        });

        state.freeCells.forEach((card, freeIndex) => {
          if (!card) return;
          const index = suits.findIndex((s) => s.name === card.suit);
          if (canMoveToFoundation(card, index)) {
            pushHistory();
            state.foundations[index] = card;
            state.freeCells[freeIndex] = null;
            state.moveCount += 1;
            moved = true;
          }
        });

        return moved;
      }

      function autoMoveAll() {
        let moved = false;
        while (autoMoveOnce()) {
          moved = true;
        }
        return moved;
      }

      function clearSelection() {
        state.selection = null;
      }

      function selectCard(source, cardIndex) {
        state.selection = { ...source, cardIndex };
      }

      function handleCardClick(source, cardIndex, hasCard) {
        if (!hasCard) {
          clearSelection();
          render();
          return;
        }

        if (!state.selection) {
          selectCard(source, cardIndex);
          render();
          return;
        }

        const selection = state.selection;
        const same = JSON.stringify(selection) === JSON.stringify({ ...source, cardIndex });
        if (same) {
          clearSelection();
          render();
          return;
        }

        selectCard(source, cardIndex);
        render();
      }

      function getSourceFromSelection(selection) {
        if (selection.type === "tableau") {
          return {
            type: "tableau",
            column: selection.column,
            cardIndex: selection.cardIndex,
            card: state.tableau[selection.column][selection.cardIndex],
          };
        }
        if (selection.type === "free") {
          return { type: "free", index: selection.index, card: state.freeCells[selection.index] };
        }
        return { type: "foundation", index: selection.index, card: state.foundations[selection.index] };
      }

      function isSameSelection(source, cardIndex) {
        if (!state.selection) return false;
        if (state.selection.type !== source.type) return false;
        if (source.type === "tableau") {
          return state.selection.column === source.column && state.selection.cardIndex === cardIndex;
        }
        return state.selection.index === source.index;
      }

      function buildPips(card) {
        if (card.value > 10) {
          return `<div><div class="face-rank">${card.rank}</div><div class="face-suit">${card.symbol}</div></div>`;
        }
        const pips = Array.from({ length: card.value }, () => `<span class="pip">${card.symbol}</span>`).join("");
        return `<div class="pips" data-count="${card.value}">${pips}</div>`;
      }

      function renderCard(card, source, cardIndex = 0) {
        const cardEl = document.createElement("div");
        cardEl.className = `card ${card.color}${source.type === "tableau" ? " tableau-card" : ""}`;
        cardEl.innerHTML = `
          <div class="corner top">${card.rank}<span class="small-suit">${card.symbol}</span></div>
          <div class="center">${buildPips(card)}</div>
          <div class="corner bottom">${card.rank}<span class="small-suit">${card.symbol}</span></div>
        `;

        if (state.selection && isSameSelection(source, cardIndex)) {
          cardEl.classList.add("selected");
        }

        cardEl.addEventListener("click", (event) => {
          event.stopPropagation();
          handleCardClick(source, cardIndex, true);
        });

        cardEl.setAttribute("draggable", "true");
        cardEl.addEventListener("dragstart", (event) => {
          dragSource = { ...source, cardIndex };
          cardEl.classList.add("dragging");
          event.dataTransfer.setData("text/plain", "card");
        });

        cardEl.addEventListener("dragend", () => {
          cardEl.classList.remove("dragging");
          dragSource = null;
        });

        cardEl.addEventListener("dblclick", (event) => {
          event.stopPropagation();
          if (source.type === "tableau") {
            const column = state.tableau[source.column];
            if (column[column.length - 1] !== card) return;
          }
          const foundationIndex = suits.findIndex((s) => s.name === card.suit);
          const from = getSourceFromSelection({ ...source, cardIndex });
          if (moveSingleCard(from, { type: "foundation", index: foundationIndex })) {
            clearSelection();
            render();
          }
        });

        return cardEl;
      }

      function renderTopRow() {
        topRow.innerHTML = "";

        state.freeCells.forEach((card, index) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.type = "free";
          cell.dataset.index = index;
          cell.innerHTML = `<div class="cell-label">FREE</div>`;

          if (card) {
            cell.appendChild(renderCard(card, { type: "free", index }));
          }

          cell.addEventListener("click", () => {
            handleCardClick({ type: "free", index }, 0, Boolean(card));
          });

          cell.addEventListener("dragover", (event) => {
            event.preventDefault();
            cell.classList.add("drop-ready");
          });
          cell.addEventListener("dragleave", () => cell.classList.remove("drop-ready"));
          cell.addEventListener("drop", () => {
            cell.classList.remove("drop-ready");
            if (!dragSource) return;

            if (dragSource.type === "tableau") {
              const col = state.tableau[dragSource.column];
              if (col[col.length - 1] !== col[dragSource.cardIndex]) {
                dragSource = null;
                return;
              }
            }

            moveSingleCard(getSourceFromSelection(dragSource), { type: "free", index });
            dragSource = null;
            clearSelection();
            render();
          });

          topRow.appendChild(cell);
        });

        const separator = document.createElement("div");
        separator.className = "separator";
        topRow.appendChild(separator);

        state.foundations.forEach((card, index) => {
          const foundation = document.createElement("div");
          foundation.className = "foundation";
          foundation.dataset.type = "foundation";
          foundation.dataset.index = index;
          foundation.innerHTML = `<div class="cell-label">${suits[index].symbol}</div>`;

          if (card) {
            foundation.appendChild(renderCard(card, { type: "foundation", index }));
          }

          foundation.addEventListener("click", () => {
            handleCardClick({ type: "foundation", index }, 0, Boolean(card));
          });

          foundation.addEventListener("dragover", (event) => {
            event.preventDefault();
            foundation.classList.add("drop-ready");
          });
          foundation.addEventListener("dragleave", () => foundation.classList.remove("drop-ready"));
          foundation.addEventListener("drop", () => {
            foundation.classList.remove("drop-ready");
            if (!dragSource) return;

            if (dragSource.type === "tableau") {
              const col = state.tableau[dragSource.column];
              if (col[col.length - 1] !== col[dragSource.cardIndex]) {
                dragSource = null;
                return;
              }
            }

            moveSingleCard(getSourceFromSelection(dragSource), { type: "foundation", index });
            dragSource = null;
            clearSelection();
            render();
          });

          topRow.appendChild(foundation);
        });
      }

      function renderTableau() {
        tableauEl.innerHTML = "";
        const stackGap =
          Number.parseInt(getComputedStyle(document.documentElement).getPropertyValue("--stack-gap"), 10) || 34;

        state.tableau.forEach((col, colIndex) => {
          const column = document.createElement("div");
          column.className = "column";
          column.dataset.column = colIndex;

          column.addEventListener("click", () => {
            const hasCard = col.length > 0;
            const index = hasCard ? col.length - 1 : 0;
            handleCardClick({ type: "tableau", column: colIndex }, index, hasCard);
          });

          column.addEventListener("dragover", (event) => {
            event.preventDefault();
            column.classList.add("drop-ready");
          });
          column.addEventListener("dragleave", () => column.classList.remove("drop-ready"));
          column.addEventListener("drop", () => {
            column.classList.remove("drop-ready");
            if (!dragSource) return;

            const selection = dragSource;
            const isStackSelection =
              selection.type === "tableau" && selection.cardIndex < state.tableau[selection.column].length - 1;

            if (isStackSelection) {
              moveStackToTableau(selection, colIndex);
            } else {
              moveSingleCard(getSourceFromSelection(selection), { type: "tableau", index: colIndex });
            }

            dragSource = null;
            clearSelection();
            render();
          });

          if (col.length === 0) {
            const empty = document.createElement("div");
            empty.className = "empty-msg";
            empty.textContent = "빈 열";
            column.appendChild(empty);
          }

          col.forEach((card, cardIndex) => {
            const cardEl = renderCard(card, { type: "tableau", column: colIndex }, cardIndex);
            cardEl.style.top = `${cardIndex * stackGap}px`;
            column.appendChild(cardEl);
          });

          tableauEl.appendChild(column);
        });
      }

      function updateStatus() {
        moveCountEl.textContent = state.moveCount;
        const freeUsed = state.freeCells.filter(Boolean).length;
        freeCountEl.textContent = `${4 - freeUsed} / 4`;
        const remaining =
          state.tableau.reduce((acc, col) => acc + col.length, 0) +
          state.freeCells.filter(Boolean).length;
        remainingCountEl.textContent = remaining;
      }

      function render() {
        renderTopRow();
        renderTableau();
        updateStatus();
      }

      function newGame() {
        state.freeCells = Array(4).fill(null);
        state.foundations = Array(4).fill(null);
        state.moveCount = 0;
        state.history = [];
        state.selection = null;
        deal();
        render();
      }

      newGameBtn.addEventListener("click", newGame);
      undoBtn.addEventListener("click", () => {
        const snap = state.history.pop();
        if (snap) {
          restore(snap);
          clearSelection();
          render();
        }
      });
      autoBtn.addEventListener("click", () => {
        autoMoveAll();
        clearSelection();
        render();
      });

      document.title = `FreeCell v${VERSION}`;
      newGame();
    </script>
  </body>
</html>
