<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chrome Dino Clone</title>
    <style>
      :root {
        --bg: #e7f4ff;
        --ink: #1f3550;
        --line: #8ab4d6;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: var(--bg);
        color: var(--ink);
        font-family: "Segoe UI", Tahoma, sans-serif;
      }

      .game-wrap {
        width: min(920px, 96vw);
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        border-bottom: 1px solid var(--line);
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        background: #f8fcff;
      }

      .help {
        margin-top: 10px;
        font-size: 13px;
        text-align: center;
        color: #45627f;
      }
    </style>
  </head>
  <body>
    <div class="game-wrap">
      <canvas id="game" width="920" height="220" aria-label="Chrome Dino Game"></canvas>
      <div class="help">`Space` / `↑`: 점프, `↓`: 숙이기, 게임 오버 시 `Space`로 재시작</div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;
      const GROUND_Y = 182;
      const GRAVITY = 0.56;
      const JUMP_POWER = 11.6;
      const EXTRA_JUMP_FRAMES = 6;
      const EXTRA_JUMP_BOOST = 0.18;
      const BASE_SPEED = 6.2;
      const DIFFICULTY_RAMP_START = 150;
      const DIFFICULTY_SCORE_MAX = 1900;
      const RHYTHM_PATTERN = [1.42, 1.18, 1.32, 1.06, 1.52, 1.2, 1.35, 1.0];
      const PALETTE = {
        cloud: "#f1f8ff",
        groundLine: "#3e7d4f",
        groundDust: "#69a96f",
        dinoBase: "#1f9e5a",
        dinoAccent: "#176c40",
        dinoEye: "#ffffff",
        cactusBase: "#2f9f66",
        cactusAccent: "#1f6f47",
        pteraBase: "#ff8b3d",
        pteraAccent: "#a84b1f",
        uiText: "#2b4663",
        promptText: "#3b5f85",
        gameOver: "#d24343",
        shadowRgb: "26, 78, 52",
      };

      const state = {
        running: false,
        gameOver: false,
        score: 0,
        hi: Number(localStorage.getItem("dino-hi") || 0),
        speed: BASE_SPEED,
        tick: 0,
        blinkTick: 0,
        spawnCooldown: 420,
        rhythmStep: 0,
      };

      const input = {
        up: false,
        down: false,
      };

      const dino = {
        x: 64,
        y: GROUND_Y - 44,
        width: 44,
        height: 44,
        duckHeight: 28,
        vy: 0,
        grounded: true,
        ducking: false,
        frame: 0,
        jumpBoostFrames: 0,
        landSquashFrames: 0,
      };

      const obstacles = [];
      const clouds = [];
      const groundSegments = [];

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function addCloud() {
        clouds.push({
          x: WIDTH + rand(10, 260),
          y: rand(24, 88),
          w: rand(42, 68),
          h: rand(14, 22),
          speed: rand(0.8, 1.9),
        });
      }

      function addGroundSegment(startX) {
        groundSegments.push({
          x: startX,
          len: rand(30, 110),
        });
      }

      function getDifficulty() {
        const progress = Math.max(0, state.score - DIFFICULTY_RAMP_START);
        return Math.min(1, progress / DIFFICULTY_SCORE_MAX);
      }

      function getNextSpawnGap() {
        const difficulty = getDifficulty();
        const baseGap = 390 - difficulty * 170;
        const beat = RHYTHM_PATTERN[state.rhythmStep % RHYTHM_PATTERN.length];
        let gap = baseGap * beat + rand(-14, 20);

        // Make the first section noticeably easier.
        if (state.score < 300) gap += rand(80, 140);
        else if (state.score < 700) gap += rand(20, 60);

        // Every phrase can include a breathing beat. It appears more often early.
        if (state.rhythmStep % 4 === 3 && Math.random() < 0.72 - difficulty * 0.42) {
          gap += rand(90, 160);
        }

        state.rhythmStep += 1;
        return Math.max(190, Math.min(620, gap));
      }

      function addObstacle() {
        const difficulty = getDifficulty();
        const pteraChance = Math.max(0, (difficulty - 0.18) * 0.5);
        const isPtera = state.score > 260 && Math.random() < pteraChance;
        const spawnX = WIDTH + rand(18, 32);
        if (isPtera) {
          const lowFlight = state.score > 380 && Math.random() < 0.62;
          obstacles.push({
            type: "ptera",
            x: spawnX,
            y: lowFlight ? GROUND_Y - 49 : GROUND_Y - 72,
            width: 46,
            height: 30,
            wing: 0,
          });
          return;
        }

        const kind = Math.random() < 0.55 ? "small" : "big";
        if (kind === "small") {
          obstacles.push({
            type: "cactus",
            x: spawnX,
            y: GROUND_Y - 38,
            width: 26,
            height: 38,
          });
          return;
        }

        obstacles.push({
          type: "cactus",
          x: spawnX,
          y: GROUND_Y - 54,
          width: 34,
          height: 54,
        });
      }

      function resetWorld() {
        obstacles.length = 0;
        clouds.length = 0;
        groundSegments.length = 0;
        for (let i = 0; i < 6; i += 1) addCloud();
        let gx = 0;
        while (gx < WIDTH + 120) {
          addGroundSegment(gx);
          gx += rand(38, 140);
        }
      }

      function restart() {
        state.running = false;
        state.gameOver = false;
        state.score = 0;
        state.speed = BASE_SPEED;
        state.tick = 0;
        state.blinkTick = 0;
        state.spawnCooldown = 420;
        state.rhythmStep = 0;
        dino.y = GROUND_Y - 44;
        dino.vy = 0;
        dino.grounded = true;
        dino.ducking = false;
        resetWorld();
      }

      function beginGame() {
        if (state.gameOver) {
          restart();
        }
        state.running = true;
      }

      function jump() {
        if (!dino.grounded) return;
        dino.vy = -JUMP_POWER;
        dino.grounded = false;
        dino.jumpBoostFrames = EXTRA_JUMP_FRAMES;
      }

      function updateDino() {
        const wasGrounded = dino.grounded;
        dino.ducking = input.down && dino.grounded;
        dino.height = dino.ducking ? dino.duckHeight : 44;

        if (!dino.grounded) {
          if (input.up && dino.vy < -2 && dino.jumpBoostFrames > 0) {
            dino.vy -= EXTRA_JUMP_BOOST;
            dino.jumpBoostFrames -= 1;
          }
          dino.vy += GRAVITY;
          dino.y += dino.vy;
          const groundY = GROUND_Y - dino.height;
          if (dino.y >= groundY) {
            dino.y = groundY;
            dino.vy = 0;
            dino.grounded = true;
            if (!wasGrounded) dino.landSquashFrames = 8;
          }
        } else {
          dino.y = GROUND_Y - dino.height;
          dino.jumpBoostFrames = 0;
        }

        if (dino.landSquashFrames > 0) dino.landSquashFrames -= 1;

        if (state.running && !state.gameOver) {
          dino.frame = (dino.frame + Math.max(0.9, state.speed / 6.2)) % 12;
        }
      }

      function updateClouds() {
        for (const c of clouds) {
          c.x -= c.speed;
        }
        if (clouds.length && clouds[0].x + clouds[0].w < -20) {
          clouds.shift();
          addCloud();
        }
      }

      function updateGround() {
        for (const g of groundSegments) {
          g.x -= state.speed;
        }
        while (groundSegments.length && groundSegments[0].x + groundSegments[0].len < -10) {
          groundSegments.shift();
        }
        if (!groundSegments.length || groundSegments[groundSegments.length - 1].x < WIDTH - 30) {
          addGroundSegment(WIDTH + rand(12, 80));
        }
      }

      function updateObstacles() {
        if (!state.running || state.gameOver) return;

        for (const o of obstacles) {
          o.x -= state.speed;
          if (o.type === "ptera") {
            o.wing = (o.wing + 1) % 18;
          }
        }
        while (obstacles.length && obstacles[0].x + obstacles[0].width < -20) {
          obstacles.shift();
        }

        state.spawnCooldown -= state.speed;
        if (state.spawnCooldown <= 0) {
          addObstacle();
          state.spawnCooldown = getNextSpawnGap();
        }
      }

      function getDinoHitbox() {
        const padX = dino.ducking ? 6 : 8;
        const padY = dino.ducking ? 5 : 4;
        return {
          x: dino.x + padX,
          y: dino.y + padY,
          w: dino.width - padX * 2,
          h: dino.height - padY * 2,
        };
      }

      function getObstacleHitbox(o) {
        if (o.type === "ptera") {
          return { x: o.x + 5, y: o.y + 8, w: o.width - 10, h: o.height - 13 };
        }
        return { x: o.x + 3, y: o.y + 2, w: o.width - 6, h: o.height - 4 };
      }

      function intersects(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      function checkCollision() {
        const db = getDinoHitbox();
        for (const o of obstacles) {
          if (intersects(db, getObstacleHitbox(o))) {
            state.gameOver = true;
            state.running = false;
            state.hi = Math.max(state.hi, Math.floor(state.score));
            localStorage.setItem("dino-hi", String(state.hi));
            return;
          }
        }
      }

      function updateScore() {
        if (!state.running || state.gameOver) return;
        state.score += 0.1;
        const difficulty = getDifficulty();
        state.speed = BASE_SPEED + 5.2 * Math.pow(difficulty, 1.35);
      }

      function drawCloud(c) {
        ctx.fillStyle = PALETTE.cloud;
        ctx.fillRect(c.x, c.y + 8, c.w, c.h - 8);
        ctx.fillRect(c.x + 8, c.y, c.w * 0.45, c.h * 0.7);
        ctx.fillRect(c.x + c.w * 0.42, c.y + 2, c.w * 0.46, c.h * 0.8);
      }

      function drawGround() {
        ctx.strokeStyle = PALETTE.groundLine;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y + 0.5);
        ctx.lineTo(WIDTH, GROUND_Y + 0.5);
        ctx.stroke();

        ctx.fillStyle = PALETTE.groundDust;
        for (const g of groundSegments) {
          ctx.fillRect(g.x, GROUND_Y + 6, g.len, 2);
        }
      }

      function drawDinoShadow() {
        const altitude = Math.max(0, GROUND_Y - (dino.y + dino.height));
        const spread = 1 + altitude / 85;
        const alpha = Math.max(0.06, 0.18 - altitude / 420);
        ctx.save();
        ctx.fillStyle = `rgba(${PALETTE.shadowRgb}, ${alpha.toFixed(3)})`;
        ctx.beginPath();
        ctx.ellipse(dino.x + dino.width / 2, GROUND_Y + 4, 14 * spread, 4.2 * spread, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawDino() {
        const runAlt = dino.frame < 6;
        const eyeOpen = Math.floor(state.tick / 26) % 8 !== 0;
        const x = dino.x;
        const y = dino.y;
        const h = dino.height;

        let scaleX = 1;
        let scaleY = 1;
        if (!dino.grounded) {
          if (dino.vy < -1) {
            scaleX = 0.94;
            scaleY = 1.08;
          } else {
            scaleX = 1.07;
            scaleY = 0.94;
          }
        }
        if (dino.landSquashFrames > 0) {
          const squash = dino.landSquashFrames / 8;
          scaleX += 0.09 * squash;
          scaleY -= 0.09 * squash;
        }

        ctx.save();
        const pivotX = x + dino.width / 2;
        const pivotY = y + h;
        ctx.translate(pivotX, pivotY);
        ctx.scale(scaleX, scaleY);
        ctx.translate(-pivotX, -pivotY);
        ctx.fillStyle = PALETTE.dinoBase;

        if (dino.ducking) {
          ctx.fillRect(x + 0, y + 16, 10, 7);
          ctx.fillRect(x + 6, y + 13, 24, 10);
          ctx.fillRect(x + 27, y + 9, 13, 10);
          ctx.fillRect(x + 37, y + 11, 7, 5);
          ctx.fillRect(x + 11, y + 20, 16, 3);
          ctx.fillRect(x + 6, y + 19, 4, 5);
          ctx.fillRect(x + (runAlt ? 16 : 23), y + 22, 8, 5);

          ctx.fillStyle = PALETTE.dinoEye;
          if (eyeOpen) ctx.fillRect(x + 32, y + 12, 2, 2);
          ctx.fillStyle = PALETTE.dinoAccent;
          ctx.fillRect(x + 10, y + 15, 16, 2);
          ctx.fillRect(x + 31, y + 14, 10, 1);
          ctx.fillStyle = PALETTE.dinoBase;
        } else {
          ctx.fillRect(x + 2, y + 22, 8, 6);
          ctx.fillRect(x + 0, y + 24, 4, 4);
          ctx.fillRect(x + 8, y + 14, 18, 14);
          ctx.fillRect(x + 22, y + 9, 7, 10);
          ctx.fillRect(x + 26, y + 3, 12, 12);
          ctx.fillRect(x + 36, y + 6, 8, 6);
          ctx.fillRect(x + 33, y + 11, 9, 3);
          ctx.fillRect(x + 18, y + 19, 4, 4);

          if (runAlt) {
            ctx.fillRect(x + 10, y + h - 8, 7, 8);
            ctx.fillRect(x + 11, y + h - 1, 5, 2);
            ctx.fillRect(x + 22, y + h - 6, 7, 6);
            ctx.fillRect(x + 24, y + h - 1, 5, 2);
          } else {
            ctx.fillRect(x + 10, y + h - 6, 7, 6);
            ctx.fillRect(x + 12, y + h - 1, 5, 2);
            ctx.fillRect(x + 22, y + h - 8, 7, 8);
            ctx.fillRect(x + 23, y + h - 1, 5, 2);
          }

          ctx.fillStyle = PALETTE.dinoEye;
          if (eyeOpen) ctx.fillRect(x + 33, y + 6, 2, 2);

          ctx.fillStyle = PALETTE.dinoAccent;
          ctx.fillRect(x + 10, y + 16, 11, 2);
          ctx.fillRect(x + 10, y + 24, 12, 2);
          ctx.fillRect(x + 31, y + 12, 10, 1);
          ctx.fillStyle = PALETTE.dinoBase;
        }
        ctx.restore();
      }

      function drawCactus(o) {
        ctx.fillStyle = PALETTE.cactusBase;
        ctx.fillRect(o.x + 8, o.y + 2, o.width - 16, o.height - 2);
        ctx.fillRect(o.x + 5, o.y + 4, 4, 6);
        ctx.fillRect(o.x + o.width - 9, o.y + 9, 4, 7);
        ctx.fillRect(o.x + 2, o.y + 11, 8, 13);
        ctx.fillRect(o.x + o.width - 10, o.y + 17, 8, 15);
        ctx.fillStyle = PALETTE.cactusAccent;
        ctx.fillRect(o.x + 12, o.y + 6, 2, o.height - 12);
        ctx.fillRect(o.x + o.width - 14, o.y + 10, 2, o.height - 18);
        ctx.fillStyle = PALETTE.cactusBase;
      }

      function drawPteranodon(o) {
        const wingUp = o.wing < 9;
        ctx.fillStyle = PALETTE.pteraBase;
        ctx.fillRect(o.x + 11, o.y + 11, 22, 8);
        ctx.fillRect(o.x + 31, o.y + 9, 10, 7);
        ctx.fillRect(o.x + 38, o.y + 7, 5, 4);
        ctx.fillRect(o.x + 7, o.y + 14, 7, 4);
        if (wingUp) {
          ctx.fillRect(o.x + 2, o.y + 8, 14, 5);
          ctx.fillRect(o.x + 16, o.y + 4, 13, 4);
          ctx.fillRect(o.x + 24, o.y + 2, 12, 4);
        } else {
          ctx.fillRect(o.x + 2, o.y + 15, 14, 5);
          ctx.fillRect(o.x + 16, o.y + 18, 13, 4);
          ctx.fillRect(o.x + 24, o.y + 20, 12, 4);
        }
        ctx.fillStyle = PALETTE.pteraAccent;
        ctx.fillRect(o.x + 15, o.y + 12, 11, 2);
        ctx.fillStyle = PALETTE.pteraBase;
      }

      function drawObstacles() {
        for (const o of obstacles) {
          if (o.type === "ptera") drawPteranodon(o);
          else drawCactus(o);
        }
      }

      function drawScore() {
        const scoreText = String(Math.floor(state.score)).padStart(5, "0");
        const hiText = String(Math.floor(state.hi)).padStart(5, "0");
        ctx.fillStyle = PALETTE.uiText;
        ctx.font = "20px monospace";
        ctx.textAlign = "right";
        ctx.fillText(`HI ${hiText}  ${scoreText}`, WIDTH - 18, 28);
      }

      function drawStartPrompt() {
        if (state.running || state.gameOver) return;
        state.blinkTick = (state.blinkTick + 1) % 80;
        if (state.blinkTick > 40) return;
        ctx.fillStyle = PALETTE.promptText;
        ctx.font = "18px monospace";
        ctx.textAlign = "center";
        ctx.fillText("PRESS SPACE TO START", WIDTH / 2, 82);
      }

      function drawGameOver() {
        if (!state.gameOver) return;
        ctx.fillStyle = PALETTE.gameOver;
        ctx.font = "28px monospace";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", WIDTH / 2, 78);

        ctx.font = "16px monospace";
        ctx.fillText("SPACE TO RESTART", WIDTH / 2, 106);

        const bx = WIDTH / 2 - 20;
        const by = 120;
        ctx.strokeStyle = PALETTE.uiText;
        ctx.strokeRect(bx, by, 40, 24);
        ctx.beginPath();
        ctx.moveTo(bx + 20, by + 5);
        ctx.lineTo(bx + 20, by + 19);
        ctx.lineTo(bx + 9, by + 12);
        ctx.stroke();
      }

      function render() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        for (const c of clouds) drawCloud(c);
        drawGround();
        drawDinoShadow();
        drawDino();
        drawObstacles();
        drawScore();
        drawStartPrompt();
        drawGameOver();
      }

      function update() {
        state.tick += 1;
        updateClouds();
        updateDino();
        updateGround();
        updateObstacles();
        checkCollision();
        updateScore();
      }

      function loop() {
        update();
        render();
        requestAnimationFrame(loop);
      }

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          if (state.gameOver || !state.running) beginGame();
          jump();
          input.up = true;
        }
        if (e.code === "ArrowDown") {
          e.preventDefault();
          input.down = true;
          if (!state.running && !state.gameOver) beginGame();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") input.up = false;
        if (e.code === "ArrowDown") input.down = false;
      });

      restart();
      loop();
    </script>
  </body>
</html>
