<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chrome Dino Clone</title>
    <style>
      :root {
        --bg: #e7f4ff;
        --ink: #1f3550;
        --line: #8ab4d6;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: var(--bg);
        color: var(--ink);
        font-family: "Segoe UI", Tahoma, sans-serif;
      }

      .game-wrap {
        width: min(1360px, 97vw);
      }

      .play-layout {
        display: flex;
        gap: 14px;
        align-items: stretch;
      }

      .game-screen {
        flex: 1;
        min-width: 0;
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        border-bottom: 1px solid var(--line);
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        background: #f8fcff;
      }

      .score-board {
        width: 250px;
        border: 1px solid var(--line);
        background: #f3f9ff;
        border-radius: 8px;
        padding: 12px;
      }

      .score-board h2 {
        margin: 0 0 10px;
        font-size: 15px;
        color: #234869;
      }

      .score-board ol {
        margin: 0;
        padding-left: 22px;
        font-size: 13px;
        line-height: 1.55;
        color: #2f5679;
      }

      .score-board li {
        white-space: nowrap;
      }

      .help {
        margin-top: 10px;
        font-size: 13px;
        text-align: center;
        color: #45627f;
      }

      @media (max-width: 980px) {
        .play-layout {
          flex-direction: column;
        }

        .score-board {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-wrap">
      <div class="play-layout">
        <div class="game-screen">
          <canvas
            id="game"
            width="1120"
            height="300"
            aria-label="Chrome Dino Game"
          ></canvas>
        </div>
        <aside class="score-board" aria-label="Top 10 scores">
          <h2>TOP 10 SCORE</h2>
          <ol id="top10List"></ol>
        </aside>
      </div>
      <div class="help">
        `Space` / `↑`: 점프, `↓`: 숙이기(프테라노돈 회피), 게임 오버 시
        `Space`로 재시작
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false;

      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;
      const GROUND_Y = HEIGHT - 52;
      const GRAVITY = 0.56;
      const JUMP_POWER = 11.6;
      const EXTRA_JUMP_FRAMES = 6;
      const EXTRA_JUMP_BOOST = 0.18;
      const BASE_SPEED = 6.2;
      const DINO_WIDTH = 60;
      const DINO_STAND_HEIGHT = 60;
      const DINO_DUCK_HEIGHT = 34;
      const DINO_STAND_RENDER_W = 84;
      const DINO_STAND_RENDER_H = 86;
      const DINO_DUCK_RENDER_W = 102;
      const DINO_DUCK_RENDER_H = 42;
      const DIFFICULTY_RAMP_START = 100;
      const DIFFICULTY_SCORE_MAX = 1450;
      const RHYTHM_PATTERN = [1.42, 1.18, 1.32, 1.06, 1.52, 1.2, 1.35, 1.0];
      const TOP10_KEY = "dino-top10";
      const PALETTE = {
        cloud: "#6ea7cf",
        groundLine: "#3e7d4f",
        groundDust: "#69a96f",
        dinoBase: "#1f9e5a",
        dinoAccent: "#176c40",
        dinoEye: "#ffffff",
        cactusBase: "#2f9f66",
        cactusAccent: "#1f6f47",
        pteraBase: "#ff8b3d",
        pteraAccent: "#a84b1f",
        uiText: "#2b4663",
        promptText: "#3b5f85",
        gameOver: "#d24343",
        shadowRgb: "26, 78, 52",
      };
      const top10List = document.getElementById("top10List");

      const spriteSheet = new Image();
      const SPRITE = {
        dino: {
          x: 848,
          y: 2,
          w: 44,
          h: 47,
          idleFrame: 44,
          runFrames: [88, 132],
          crashedFrame: 220,
          jumpFrame: 0,
          duckFrames: [264, 323],
          duckW: 59,
          duckH: 25,
        },
        cactus: {
          small: { x: 228, y: 2, w: 17, h: 35 },
          large: { x: 332, y: 2, w: 25, h: 50 },
        },
        ptera: {
          x: 134,
          y: 2,
          w: 46,
          h: 40,
          frames: [0, 46],
        },
      };

      const state = {
        running: false,
        gameOver: false,
        score: 0,
        hi: Number(localStorage.getItem("dino-hi") || 0),
        speed: BASE_SPEED,
        tick: 0,
        blinkTick: 0,
        spawnCooldown: 420,
        rhythmStep: 0,
        top10: [],
        scoreLogged: false,
      };

      const input = {
        up: false,
        down: false,
      };

      const dino = {
        x: 64,
        y: GROUND_Y - DINO_STAND_HEIGHT,
        width: DINO_WIDTH,
        height: DINO_STAND_HEIGHT,
        duckHeight: DINO_DUCK_HEIGHT,
        vy: 0,
        grounded: true,
        ducking: false,
        frame: 0,
        jumpBoostFrames: 0,
        landSquashFrames: 0,
      };

      const obstacles = [];
      const clouds = [];
      const groundSegments = [];

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function loadTop10() {
        try {
          const rows = JSON.parse(localStorage.getItem(TOP10_KEY) || "[]");
          if (!Array.isArray(rows)) return [];
          return rows
            .map((v) => Number(v) || 0)
            .filter((v) => v > 0)
            .sort((a, b) => b - a)
            .slice(0, 10);
        } catch {
          return [];
        }
      }

      function renderTop10() {
        if (!state.top10.length) {
          top10List.innerHTML = "<li>아직 기록 없음</li>";
          return;
        }
        top10List.innerHTML = state.top10
          .map(
            (score, index) =>
              `<li>#${String(index + 1).padStart(2, "0")} - ${score} 점</li>`,
          )
          .join("");
      }

      function recordTop10(score) {
        if (state.scoreLogged) return;
        state.scoreLogged = true;
        const finalScore = Math.floor(score);
        state.top10 = [...state.top10, finalScore]
          .sort((a, b) => b - a)
          .slice(0, 10);
        localStorage.setItem(TOP10_KEY, JSON.stringify(state.top10));
        renderTop10();
      }

      function addCloud() {
        clouds.push({
          x: WIDTH + rand(10, 260),
          y: rand(24, 88),
          w: rand(42, 68),
          h: rand(14, 22),
          speed: rand(0.8, 1.9),
        });
      }

      function addGroundSegment(startX) {
        groundSegments.push({
          x: startX,
          len: rand(30, 110),
        });
      }

      function getDifficulty() {
        const progress = Math.max(0, state.score - DIFFICULTY_RAMP_START);
        return Math.min(1, progress / DIFFICULTY_SCORE_MAX);
      }

      function getNextSpawnGap() {
        const difficulty = getDifficulty();
        const baseGap = 390 - difficulty * 170;
        const beat = RHYTHM_PATTERN[state.rhythmStep % RHYTHM_PATTERN.length];
        let gap = baseGap * beat + rand(-14, 20);

        if (state.score < 250) gap += rand(45, 95);
        else if (state.score < 500) gap += rand(10, 35);

        // Every phrase can include a breathing beat. It appears more often early.
        if (
          state.rhythmStep % 4 === 3 &&
          Math.random() < 0.72 - difficulty * 0.42
        ) {
          gap += rand(90, 160);
        }

        state.rhythmStep += 1;
        return Math.max(190, Math.min(620, gap));
      }

      function addObstacle() {
        const difficulty = getDifficulty();
        const pteraChance = Math.max(0, 0.06 + (difficulty - 0.08) * 0.62);
        const isPtera = state.score > 170 && Math.random() < pteraChance;
        const spawnX = WIDTH + rand(18, 32);
        if (isPtera) {
          obstacles.push({
            type: "ptera",
            x: spawnX,
            y: GROUND_Y - 82,
            width: 62,
            height: 54,
            wing: 0,
            prevX: spawnX,
          });
          return;
        }

        const kind = Math.random() < 0.55 ? "small" : "big";
        if (kind === "small") {
          obstacles.push({
            type: "cactus",
            x: spawnX,
            y: GROUND_Y - 52,
            width: 34,
            height: 52,
            prevX: spawnX,
          });
          return;
        }

        obstacles.push({
          type: "cactus",
          x: spawnX,
          y: GROUND_Y - 72,
          width: 44,
          height: 72,
          prevX: spawnX,
        });
      }

      function resetWorld() {
        obstacles.length = 0;
        clouds.length = 0;
        groundSegments.length = 0;
        for (let i = 0; i < 6; i += 1) addCloud();
        let gx = 0;
        while (gx < WIDTH + 120) {
          addGroundSegment(gx);
          gx += rand(38, 140);
        }
      }

      function restart() {
        state.running = false;
        state.gameOver = false;
        state.score = 0;
        state.speed = BASE_SPEED;
        state.tick = 0;
        state.blinkTick = 0;
        state.spawnCooldown = 420;
        state.rhythmStep = 0;
        state.scoreLogged = false;
        dino.y = GROUND_Y - DINO_STAND_HEIGHT;
        dino.vy = 0;
        dino.grounded = true;
        dino.ducking = false;
        dino.height = DINO_STAND_HEIGHT;
        dino.frame = 0;
        resetWorld();
      }

      function beginGame() {
        if (state.gameOver) {
          restart();
        }
        state.running = true;
      }

      function jump() {
        if (!dino.grounded) return;
        dino.vy = -JUMP_POWER;
        dino.grounded = false;
        dino.jumpBoostFrames = EXTRA_JUMP_FRAMES;
      }

      function updateDino() {
        const wasGrounded = dino.grounded;
        dino.ducking = input.down && dino.grounded;
        dino.height = dino.ducking ? dino.duckHeight : DINO_STAND_HEIGHT;

        if (!dino.grounded) {
          if (input.up && dino.vy < -2 && dino.jumpBoostFrames > 0) {
            dino.vy -= EXTRA_JUMP_BOOST;
            dino.jumpBoostFrames -= 1;
          }
          dino.vy += GRAVITY;
          dino.y += dino.vy;
          const groundY = GROUND_Y - dino.height;
          if (dino.y >= groundY) {
            dino.y = groundY;
            dino.vy = 0;
            dino.grounded = true;
            if (!wasGrounded) dino.landSquashFrames = 8;
          }
        } else {
          dino.y = GROUND_Y - dino.height;
          dino.jumpBoostFrames = 0;
        }

        if (dino.landSquashFrames > 0) dino.landSquashFrames -= 1;

        if (state.running && !state.gameOver) {
          dino.frame = (dino.frame + Math.max(0.9, state.speed / 6.2)) % 12;
        }
      }

      function updateClouds() {
        for (const c of clouds) {
          c.x -= c.speed;
        }
        if (clouds.length && clouds[0].x + clouds[0].w < -20) {
          clouds.shift();
          addCloud();
        }
      }

      function updateGround() {
        for (const g of groundSegments) {
          g.x -= state.speed;
        }
        while (
          groundSegments.length &&
          groundSegments[0].x + groundSegments[0].len < -10
        ) {
          groundSegments.shift();
        }
        if (
          !groundSegments.length ||
          groundSegments[groundSegments.length - 1].x < WIDTH - 30
        ) {
          addGroundSegment(WIDTH + rand(12, 80));
        }
      }

      function updateObstacles() {
        if (!state.running || state.gameOver) return;

        for (const o of obstacles) {
          o.prevX = o.x;
          o.x -= state.speed;
          if (o.type === "ptera") {
            o.wing = (o.wing + 1) % 18;
          }
        }
        while (obstacles.length && obstacles[0].x + obstacles[0].width < -20) {
          obstacles.shift();
        }

        state.spawnCooldown -= state.speed;
        if (state.spawnCooldown <= 0) {
          addObstacle();
          state.spawnCooldown = getNextSpawnGap();
        }
      }

      function getDinoHitbox() {
        const padX = dino.ducking ? 10 : 12;
        const padY = dino.ducking ? 7 : 8;
        return {
          x: dino.x + padX,
          y: dino.y + padY,
          w: dino.width - padX * 2,
          h: dino.height - padY * 2,
        };
      }

      function getObstacleHitbox(o) {
        if (o.type === "ptera") {
          return { x: o.x + 8, y: o.y + 10, w: o.width - 16, h: o.height - 20 };
        }
        return { x: o.x + 5, y: o.y + 4, w: o.width - 10, h: o.height - 8 };
      }

      function intersects(a, b) {
        return (
          a.x < b.x + b.w &&
          a.x + a.w > b.x &&
          a.y < b.y + b.h &&
          a.y + a.h > b.y
        );
      }

      function checkCollision() {
        if (state.gameOver) return;
        const db = getDinoHitbox();

        const triggerGameOver = () => {
          const finalScore = Math.floor(state.score);
          state.gameOver = true;
          state.running = false;
          state.hi = Math.max(state.hi, finalScore);
          localStorage.setItem("dino-hi", String(state.hi));
          recordTop10(finalScore);
        };

        for (const o of obstacles) {
          const ob = getObstacleHitbox(o);
          const xNowOverlap = db.x < ob.x + ob.w && db.x + db.w > ob.x;
          const prevRight = (o.prevX ?? o.x) + ob.w;
          const nowLeft = ob.x;
          const xSweepOverlap = prevRight >= db.x && nowLeft <= db.x + db.w;
          const xOverlap = xNowOverlap || xSweepOverlap;

          if (o.type === "ptera") {
            if (xOverlap && !dino.ducking) {
              triggerGameOver();
              return;
            }
            continue;
          }

          if (o.type === "cactus" && xOverlap && dino.grounded) {
            triggerGameOver();
            return;
          }

          if (intersects(db, ob)) {
            triggerGameOver();
            return;
          }
        }
      }

      function updateScore() {
        if (!state.running || state.gameOver) return;
        state.score += 0.1;
        const difficulty = getDifficulty();
        state.speed = BASE_SPEED + 5.2 * Math.pow(difficulty, 1.35);
      }

      function drawCloud(c) {
        ctx.fillStyle = PALETTE.cloud;
        ctx.fillRect(c.x, c.y + 8, c.w, c.h - 8);
        ctx.fillRect(c.x + 8, c.y, c.w * 0.45, c.h * 0.7);
        ctx.fillRect(c.x + c.w * 0.42, c.y + 2, c.w * 0.46, c.h * 0.8);
      }

      function drawGround() {
        ctx.strokeStyle = PALETTE.groundLine;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y + 0.5);
        ctx.lineTo(WIDTH, GROUND_Y + 0.5);
        ctx.stroke();

        ctx.fillStyle = PALETTE.groundDust;
        for (const g of groundSegments) {
          ctx.fillRect(g.x, GROUND_Y + 6, g.len, 2);
        }
      }

      function drawDinoShadow() {
        const altitude = Math.max(0, GROUND_Y - (dino.y + dino.height));
        const spread = 1 + altitude / 85;
        const alpha = Math.max(0.06, 0.18 - altitude / 420);
        ctx.save();
        ctx.fillStyle = `rgba(${PALETTE.shadowRgb}, ${alpha.toFixed(3)})`;
        ctx.beginPath();
        ctx.ellipse(
          dino.x + dino.width / 2,
          GROUND_Y + 4,
          14 * spread,
          4.2 * spread,
          0,
          0,
          Math.PI * 2,
        );
        ctx.fill();
        ctx.restore();
      }

      function drawDino() {
        const x = dino.x;
        const y = dino.y;
        const feetY = y + dino.height;

        if (!(spriteSheet.complete && spriteSheet.naturalWidth > 0)) {
          ctx.fillStyle = PALETTE.dinoBase;
          ctx.fillRect(x + 8, y + 8, 40, dino.height - 8);
          return;
        }

        const runningFrame = Math.floor(state.tick / 7) % 2;
        let sx = SPRITE.dino.x + SPRITE.dino.idleFrame;
        let sy = SPRITE.dino.y;
        let sw = SPRITE.dino.w;
        let sh = SPRITE.dino.h;
        let dx = x - 11;
        let dy = feetY - DINO_STAND_RENDER_H;
        let dw = DINO_STAND_RENDER_W;
        let dh = DINO_STAND_RENDER_H;

        if (state.gameOver) {
          sx = SPRITE.dino.x + SPRITE.dino.crashedFrame;
        } else if (dino.ducking) {
          sx = SPRITE.dino.x + SPRITE.dino.duckFrames[runningFrame];
          sw = SPRITE.dino.duckW;
          sh = SPRITE.dino.duckH;
          dx = x - 14;
          dy = feetY - DINO_DUCK_RENDER_H;
          dw = DINO_DUCK_RENDER_W;
          dh = DINO_DUCK_RENDER_H;
        } else if (!state.running) {
          sx = SPRITE.dino.x + SPRITE.dino.idleFrame;
        } else if (!dino.grounded) {
          sx = SPRITE.dino.x + SPRITE.dino.jumpFrame;
        } else {
          sx = SPRITE.dino.x + SPRITE.dino.runFrames[runningFrame];
        }
        ctx.drawImage(
          spriteSheet,
          sx,
          sy,
          sw,
          sh,
          Math.round(dx),
          Math.round(dy),
          Math.round(dw),
          Math.round(dh),
        );
      }

      function drawCactus(o) {
        if (spriteSheet.complete && spriteSheet.naturalWidth > 0) {
          const small = o.width < 30;
          const src = small ? SPRITE.cactus.small : SPRITE.cactus.large;
          ctx.drawImage(
            spriteSheet,
            src.x,
            src.y,
            src.w,
            src.h,
            o.x,
            o.y,
            o.width,
            o.height,
          );
          return;
        }
        ctx.fillStyle = PALETTE.cactusBase;
        ctx.fillRect(o.x + 8, o.y + 2, o.width - 16, o.height - 2);
      }

      function drawPteranodon(o) {
        if (spriteSheet.complete && spriteSheet.naturalWidth > 0) {
          const frame = o.wing < 9 ? 0 : 1;
          const sx = SPRITE.ptera.x + SPRITE.ptera.frames[frame];
          ctx.drawImage(
            spriteSheet,
            sx,
            SPRITE.ptera.y,
            SPRITE.ptera.w,
            SPRITE.ptera.h,
            o.x,
            o.y,
            o.width,
            o.height,
          );
          return;
        }
        ctx.fillStyle = PALETTE.pteraBase;
        ctx.fillRect(o.x + 8, o.y + 10, 28, 8);
      }

      function drawObstacles() {
        for (const o of obstacles) {
          if (o.type === "ptera") drawPteranodon(o);
          else drawCactus(o);
        }
      }

      function drawScore() {
        const scoreText = String(Math.floor(state.score)).padStart(5, "0");
        const hiText = String(Math.floor(state.hi)).padStart(5, "0");
        ctx.fillStyle = PALETTE.uiText;
        ctx.font = "20px monospace";
        ctx.textAlign = "right";
        ctx.fillText(`HI ${hiText}  ${scoreText}`, WIDTH - 18, 28);
      }

      function drawStartPrompt() {
        if (state.running || state.gameOver) return;
        state.blinkTick = (state.blinkTick + 1) % 80;
        if (state.blinkTick > 40) return;
        ctx.fillStyle = PALETTE.promptText;
        ctx.font = "18px monospace";
        ctx.textAlign = "center";
        ctx.fillText("PRESS SPACE TO START", WIDTH / 2, 82);
      }

      function drawGameOver() {
        if (!state.gameOver) return;
        ctx.fillStyle = PALETTE.gameOver;
        ctx.font = "28px monospace";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", WIDTH / 2, 78);

        ctx.font = "16px monospace";
        ctx.fillText("SPACE TO RESTART", WIDTH / 2, 106);

        const bx = WIDTH / 2 - 20;
        const by = 120;
        ctx.strokeStyle = PALETTE.uiText;
        ctx.strokeRect(bx, by, 40, 24);
        ctx.beginPath();
        ctx.moveTo(bx + 20, by + 5);
        ctx.lineTo(bx + 20, by + 19);
        ctx.lineTo(bx + 9, by + 12);
        ctx.stroke();
      }

      function render() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        for (const c of clouds) drawCloud(c);
        drawGround();
        drawDinoShadow();
        drawDino();
        drawObstacles();
        drawScore();
        drawStartPrompt();
        drawGameOver();
      }

      function update() {
        state.tick += 1;
        updateClouds();
        updateDino();
        updateGround();
        updateObstacles();
        checkCollision();
        updateScore();
      }

      function loop() {
        update();
        render();
        requestAnimationFrame(loop);
      }

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          if (state.gameOver || !state.running) beginGame();
          jump();
          input.up = true;
        }
        if (e.code === "ArrowDown") {
          e.preventDefault();
          input.down = true;
          if (!state.running && !state.gameOver) beginGame();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") input.up = false;
        if (e.code === "ArrowDown") input.down = false;
      });

      state.top10 = loadTop10();
      if (!state.top10.length && state.hi > 0) {
        state.top10 = [state.hi];
        localStorage.setItem(TOP10_KEY, JSON.stringify(state.top10));
      }
      renderTop10();

      let booted = false;
      function bootGame() {
        if (booted) return;
        booted = true;
        restart();
        loop();
      }

      spriteSheet.addEventListener("load", bootGame);
      spriteSheet.addEventListener("error", bootGame);
      spriteSheet.src = "./offline-sprite-1x.png";
    </script>
  </body>
</html>
