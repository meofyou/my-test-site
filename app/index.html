<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>FreeCell on NAS</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Spectral:wght@400;600&display=swap");

      :root {
        --bg-1: #0b1221;
        --bg-2: #0e1b2e;
        --bg-3: #182b3f;
        --card: #f6f0e8;
        --card-ink: #111217;
        --accent: #f0b35a;
        --accent-2: #6bd1b6;
        --outline: rgba(255, 255, 255, 0.2);
        --shadow: rgba(4, 10, 24, 0.45);
        --card-w: 96px;
        --card-h: 132px;
        --col-w: 116px;
        --stack-gap: 34px;
        --gutter: 14px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        color: #e9eef6;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        background: radial-gradient(circle at 10% 20%, rgba(107, 209, 182, 0.18), transparent 40%),
          radial-gradient(circle at 80% 0%, rgba(240, 179, 90, 0.2), transparent 35%),
          linear-gradient(160deg, var(--bg-1), var(--bg-2) 45%, var(--bg-3));
      }

      .app {
        max-width: 1180px;
        margin: 0 auto;
        padding: 32px 20px 48px;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 24px;
      }

      .title {
        display: grid;
        gap: 6px;
      }

      .title h1 {
        margin: 0;
        font-size: clamp(28px, 4vw, 44px);
        letter-spacing: -0.02em;
      }

      .title p {
        margin: 0;
        font-family: "Spectral", "Georgia", serif;
        font-size: 15px;
        opacity: 0.82;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      button {
        appearance: none;
        border: 1px solid var(--outline);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        padding: 10px 16px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, background 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.16);
      }

      .status {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        margin-bottom: 20px;
      }

      .status-card {
        padding: 14px 16px;
        border-radius: 14px;
        background: rgba(10, 16, 30, 0.6);
        border: 1px solid var(--outline);
        box-shadow: 0 10px 30px var(--shadow);
        font-size: 13px;
        display: grid;
        gap: 6px;
      }

      .status-card span {
        font-size: 18px;
        font-weight: 700;
      }

      .board {
        display: grid;
        gap: 18px;
        overflow-x: auto;
        padding-bottom: 6px;
      }

      .top-row {
        display: grid;
        grid-template-columns: repeat(4, minmax(var(--col-w), 1fr)) 20px repeat(4, minmax(var(--col-w), 1fr));
        gap: var(--gutter);
        align-items: center;
        min-width: calc(8 * var(--col-w) + 7 * var(--gutter) + 20px);
      }

      .separator {
        height: 60px;
      }

      .cell,
      .foundation {
        min-height: 120px;
        min-width: var(--col-w);
        border-radius: 14px;
        border: 1px dashed rgba(255, 255, 255, 0.25);
        background: rgba(13, 22, 38, 0.55);
        display: grid;
        place-items: center;
        position: relative;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      .foundation {
        border-style: solid;
        background: rgba(240, 179, 90, 0.08);
      }

      .cell-label {
        font-size: 11px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        opacity: 0.6;
        position: absolute;
        top: 8px;
        left: 12px;
      }

      .tableau {
        display: grid;
        grid-template-columns: repeat(8, minmax(var(--col-w), 1fr));
        gap: var(--gutter);
        min-width: calc(8 * var(--col-w) + 7 * var(--gutter));
      }

      .column {
        min-height: 460px;
        min-width: var(--col-w);
        border-radius: 16px;
        border: 1px dashed rgba(255, 255, 255, 0.18);
        padding: 12px 8px 16px;
        background: rgba(10, 16, 30, 0.55);
        position: relative;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      .card {
        width: var(--card-w);
        height: var(--card-h);
        padding: 12px 10px;
        border-radius: 12px;
        background: var(--card);
        color: var(--card-ink);
        font-weight: 700;
        display: grid;
        justify-items: start;
        align-content: space-between;
        box-shadow: 0 10px 24px rgba(5, 10, 20, 0.25);
        border: 2px solid rgba(0, 0, 0, 0.08);
        transition: transform 0.15s ease, border 0.2s ease;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background-size: cover;
        background-position: center;
        cursor: grab;
        text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
      }

      .card .corner {
        font-size: 18px;
        letter-spacing: -0.02em;
      }

      .card .suit {
        font-size: 22px;
      }

      .card.red {
        color: #c8373b;
      }

      .card.black {
        color: #1b1f2b;
      }

      .card.selected {
        border-color: var(--accent);
        transform: translate(-50%, -4px);
      }

      .card.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }

      .drop-ready {
        outline: 2px solid rgba(240, 179, 90, 0.6);
        outline-offset: -4px;
        box-shadow: 0 12px 30px rgba(240, 179, 90, 0.18);
      }

      .empty-msg {
        font-size: 12px;
        opacity: 0.6;
        text-align: center;
        padding: 10px;
      }

      .rules {
        margin-top: 22px;
        padding: 16px 18px;
        border-radius: 14px;
        border: 1px solid var(--outline);
        background: rgba(12, 20, 34, 0.6);
        font-size: 13px;
        line-height: 1.6;
      }

      .rules b {
        color: var(--accent);
      }

      @media (max-width: 900px) {
        :root {
          --card-w: 86px;
          --card-h: 120px;
          --col-w: 104px;
          --stack-gap: 30px;
        }

        .top-row {
          grid-template-columns: repeat(4, minmax(var(--col-w), 1fr));
        }

        .separator {
          display: none;
        }

        .tableau {
          grid-template-columns: repeat(4, minmax(var(--col-w), 1fr));
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div class="title">
          <h1>FreeCell, NAS Edition</h1>
          <p>카드를 드래그해서 이동하세요. 클릭은 선택용으로만 동작합니다.</p>
        </div>
        <div class="controls">
          <button id="newGameBtn">새 게임</button>
          <button id="undoBtn">되돌리기</button>
          <button id="autoBtn">자동 이동</button>
        </div>
      </header>

      <section class="status">
        <div class="status-card">
          <div>이동 횟수</div>
          <span id="moveCount">0</span>
        </div>
        <div class="status-card">
          <div>자유 칸</div>
          <span id="freeCount">4</span>
        </div>
        <div class="status-card">
          <div>남은 카드</div>
          <span id="remainingCount">52</span>
        </div>
      </section>

      <div class="board">
        <div class="top-row" id="topRow"></div>
        <div class="tableau" id="tableau"></div>
      </div>

      <div class="rules">
        <b>FreeCell 규칙 요약</b> - 모든 카드를 4개의 <b>Foundation</b>에 무늬별 A~K로 올립니다.
        <br />
        <b>Tableau</b>는 색이 번갈아가며 내림차순으로 쌓을 수 있고,
        <b>Free Cell</b>은 임시 보관 공간입니다. 여러 장 이동은 빈 Free Cell/빈 컬럼 수에 따라 제한됩니다.
      </div>
    </div>

    <script>
      const suits = [
        { name: "spades", symbol: "♠", color: "black" },
        { name: "hearts", symbol: "♥", color: "red" },
        { name: "clubs", symbol: "♣", color: "black" },
        { name: "diamonds", symbol: "♦", color: "red" },
      ];
      const ranks = [
        { name: "A", value: 1 },
        { name: "2", value: 2 },
        { name: "3", value: 3 },
        { name: "4", value: 4 },
        { name: "5", value: 5 },
        { name: "6", value: 6 },
        { name: "7", value: 7 },
        { name: "8", value: 8 },
        { name: "9", value: 9 },
        { name: "10", value: 10 },
        { name: "J", value: 11 },
        { name: "Q", value: 12 },
        { name: "K", value: 13 },
      ];

      const state = {
        freeCells: Array(4).fill(null),
        foundations: Array(4).fill(null),
        tableau: Array.from({ length: 8 }, () => []),
        moveCount: 0,
        history: [],
        selection: null,
      };
      let dragSource = null;

      const topRow = document.getElementById("topRow");
      const tableauEl = document.getElementById("tableau");
      const moveCountEl = document.getElementById("moveCount");
      const freeCountEl = document.getElementById("freeCount");
      const remainingCountEl = document.getElementById("remainingCount");

      const newGameBtn = document.getElementById("newGameBtn");
      const undoBtn = document.getElementById("undoBtn");
      const autoBtn = document.getElementById("autoBtn");

      function createDeck() {
        const deck = [];
        suits.forEach((suit) => {
          ranks.forEach((rank) => {
            deck.push({
              suit: suit.name,
              symbol: suit.symbol,
              color: suit.color,
              rank: rank.name,
              value: rank.value,
            });
          });
        });
        return deck;
      }

      function shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      }

      function deal() {
        state.tableau = Array.from({ length: 8 }, () => []);
        const deck = shuffle(createDeck());
        deck.forEach((card, index) => {
          state.tableau[index % 8].push(card);
        });
      }

      function snapshot() {
        return JSON.parse(
          JSON.stringify({
            freeCells: state.freeCells,
            foundations: state.foundations,
            tableau: state.tableau,
            moveCount: state.moveCount,
          })
        );
      }

      function restore(snap) {
        state.freeCells = snap.freeCells;
        state.foundations = snap.foundations;
        state.tableau = snap.tableau;
        state.moveCount = snap.moveCount;
      }

      function pushHistory() {
        state.history.push(snapshot());
        if (state.history.length > 200) {
          state.history.shift();
        }
      }

      function isOppositeColor(cardA, cardB) {
        return cardA.color !== cardB.color;
      }

      function canStackOnTableau(card, targetCard) {
        if (!targetCard) {
          return true;
        }
        return isOppositeColor(card, targetCard) && card.value + 1 === targetCard.value;
      }

      function canMoveToFoundation(card, foundationIndex) {
        const top = state.foundations[foundationIndex];
        if (!top) {
          return card.value === 1;
        }
        return top.suit === card.suit && card.value === top.value + 1;
      }

      function getMaxMovable() {
        const free = state.freeCells.filter(Boolean).length;
        const emptyColumns = state.tableau.filter((col) => col.length === 0).length;
        return (free + 1) * Math.pow(2, emptyColumns);
      }

      function cardSvg(card) {
        const fill = card.color === "red" ? "#c8373b" : "#1b1f2b";
        const light = card.color === "red" ? "#fde8e8" : "#e9eef6";
        const svg = `
          <svg xmlns="http://www.w3.org/2000/svg" width="140" height="190" viewBox="0 0 140 190">
            <defs>
              <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0%" stop-color="#ffffff"/>
                <stop offset="100%" stop-color="${light}"/>
              </linearGradient>
            </defs>
            <rect x="4" y="4" width="132" height="182" rx="16" fill="url(#g)" stroke="#c9bfb4" stroke-width="2"/>
            <text x="18" y="28" font-size="20" font-family="Space Grotesk, Arial" font-weight="700" fill="${fill}">${card.rank}</text>
            <text x="18" y="48" font-size="20" font-family="Space Grotesk, Arial" font-weight="700" fill="${fill}">${card.symbol}</text>
            <text x="70" y="118" text-anchor="middle" font-size="68" font-family="Space Grotesk, Arial" font-weight="700" fill="${fill}">${card.symbol}</text>
            <text x="122" y="168" font-size="20" font-family="Space Grotesk, Arial" font-weight="700" fill="${fill}" transform="rotate(180 122 168)">${card.rank}</text>
            <text x="122" y="148" font-size="20" font-family="Space Grotesk, Arial" font-weight="700" fill="${fill}" transform="rotate(180 122 148)">${card.symbol}</text>
          </svg>
        `;
        return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
      }

      function getTableauStack(columnIndex, cardIndex) {
        const column = state.tableau[columnIndex];
        const stack = column.slice(cardIndex);
        for (let i = 0; i < stack.length - 1; i += 1) {
          if (!canStackOnTableau(stack[i], stack[i + 1])) {
            return null;
          }
        }
        return stack;
      }

      function moveStackToTableau(source, targetColumn) {
        const stack = getTableauStack(source.column, source.cardIndex);
        if (!stack) {
          return false;
        }
        if (stack.length > getMaxMovable()) {
          return false;
        }
        const targetCol = state.tableau[targetColumn];
        const targetTop = targetCol[targetCol.length - 1];
        if (!canStackOnTableau(stack[0], targetTop)) {
          return false;
        }
        pushHistory();
        state.tableau[targetColumn] = targetCol.concat(stack);
        state.tableau[source.column] = state.tableau[source.column].slice(0, source.cardIndex);
        state.moveCount += 1;
        return true;
      }

      function moveSingleCard(source, target) {
        const card = source.card;
        if (!card) return false;
        if (source.type === "tableau") {
          const col = state.tableau[source.column];
          if (col[col.length - 1] !== card) return false;
        }
        if (target.type === "foundation") {
          if (!canMoveToFoundation(card, target.index)) return false;
          pushHistory();
          state.foundations[target.index] = card;
          removeCardFromSource(source);
          state.moveCount += 1;
          return true;
        }
        if (target.type === "free") {
          if (state.freeCells[target.index]) return false;
          pushHistory();
          state.freeCells[target.index] = card;
          removeCardFromSource(source);
          state.moveCount += 1;
          return true;
        }
        if (target.type === "tableau") {
          const col = state.tableau[target.index];
          const top = col[col.length - 1];
          if (!canStackOnTableau(card, top)) return false;
          pushHistory();
          state.tableau[target.index].push(card);
          removeCardFromSource(source);
          state.moveCount += 1;
          return true;
        }
        return false;
      }

      function removeCardFromSource(source) {
        if (source.type === "free") {
          state.freeCells[source.index] = null;
        } else if (source.type === "foundation") {
          state.foundations[source.index] = null;
        } else if (source.type === "tableau") {
          state.tableau[source.column].pop();
        }
      }

      function autoMoveOnce() {
        let moved = false;
        state.tableau.forEach((col, colIndex) => {
          if (col.length === 0) return;
          const card = col[col.length - 1];
          const index = suits.findIndex((s) => s.name === card.suit);
          if (canMoveToFoundation(card, index)) {
            pushHistory();
            state.foundations[index] = card;
            state.tableau[colIndex].pop();
            state.moveCount += 1;
            moved = true;
          }
        });
        state.freeCells.forEach((card, freeIndex) => {
          if (!card) return;
          const index = suits.findIndex((s) => s.name === card.suit);
          if (canMoveToFoundation(card, index)) {
            pushHistory();
            state.foundations[index] = card;
            state.freeCells[freeIndex] = null;
            state.moveCount += 1;
            moved = true;
          }
        });
        return moved;
      }

      function autoMoveAll() {
        let moved = false;
        while (autoMoveOnce()) {
          moved = true;
        }
        return moved;
      }

      function clearSelection() {
        state.selection = null;
      }

      function selectCard(source, cardIndex) {
        state.selection = { ...source, cardIndex };
      }

      function handleCardClick(source, cardIndex, hasCard) {
        if (!hasCard) {
          clearSelection();
          render();
          return;
        }
        if (!state.selection) {
          selectCard(source, cardIndex);
          render();
          return;
        }
        const selection = state.selection;
        const same = JSON.stringify(selection) === JSON.stringify({ ...source, cardIndex });
        if (same) {
          clearSelection();
          render();
          return;
        }
        selectCard(source, cardIndex);
        render();
      }

      function getSourceFromSelection(selection) {
        if (selection.type === "tableau") {
          return {
            type: "tableau",
            column: selection.column,
            cardIndex: selection.cardIndex,
            card: state.tableau[selection.column][selection.cardIndex],
          };
        }
        if (selection.type === "free") {
          return { type: "free", index: selection.index, card: state.freeCells[selection.index] };
        }
        return { type: "foundation", index: selection.index, card: state.foundations[selection.index] };
      }

      function getTargetFromSource(source) {
        if (source.type === "tableau") {
          return { type: "tableau", index: source.column };
        }
        if (source.type === "free") {
          return { type: "free", index: source.index };
        }
        return { type: "foundation", index: source.index };
      }

      function renderTopRow() {
        topRow.innerHTML = "";
        state.freeCells.forEach((card, index) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.type = "free";
          cell.dataset.index = index;
          cell.innerHTML = `<div class="cell-label">FREE</div>`;
          if (card) {
            cell.appendChild(renderCard(card, { type: "free", index }));
          }
          cell.addEventListener("click", () => {
            handleCardClick({ type: "free", index }, 0, Boolean(card));
          });
          cell.addEventListener("dragover", (event) => {
            event.preventDefault();
            cell.classList.add("drop-ready");
          });
          cell.addEventListener("dragleave", () => cell.classList.remove("drop-ready"));
          cell.addEventListener("drop", () => {
            cell.classList.remove("drop-ready");
            if (!dragSource) return;
            if (dragSource.type === "tableau") {
              const col = state.tableau[dragSource.column];
              if (col[col.length - 1] !== col[dragSource.cardIndex]) {
                dragSource = null;
                return;
              }
            }
            moveSingleCard(getSourceFromSelection(dragSource), { type: "free", index });
            dragSource = null;
            clearSelection();
            render();
          });
          topRow.appendChild(cell);
        });

        const separator = document.createElement("div");
        separator.className = "separator";
        topRow.appendChild(separator);

        state.foundations.forEach((card, index) => {
          const foundation = document.createElement("div");
          foundation.className = "foundation";
          foundation.dataset.type = "foundation";
          foundation.dataset.index = index;
          foundation.innerHTML = `<div class="cell-label">${suits[index].symbol}</div>`;
          if (card) {
            foundation.appendChild(renderCard(card, { type: "foundation", index }));
          }
          foundation.addEventListener("click", () => {
            handleCardClick({ type: "foundation", index }, 0, Boolean(card));
          });
          foundation.addEventListener("dragover", (event) => {
            event.preventDefault();
            foundation.classList.add("drop-ready");
          });
          foundation.addEventListener("dragleave", () => foundation.classList.remove("drop-ready"));
          foundation.addEventListener("drop", () => {
            foundation.classList.remove("drop-ready");
            if (!dragSource) return;
            if (dragSource.type === "tableau") {
              const col = state.tableau[dragSource.column];
              if (col[col.length - 1] !== col[dragSource.cardIndex]) {
                dragSource = null;
                return;
              }
            }
            moveSingleCard(getSourceFromSelection(dragSource), { type: "foundation", index });
            dragSource = null;
            clearSelection();
            render();
          });
          topRow.appendChild(foundation);
        });
      }

      function renderTableau() {
        tableauEl.innerHTML = "";
        const stackGap =
          Number.parseInt(getComputedStyle(document.documentElement).getPropertyValue("--stack-gap"), 10) || 34;
        state.tableau.forEach((col, colIndex) => {
          const column = document.createElement("div");
          column.className = "column";
          column.dataset.column = colIndex;
          column.addEventListener("click", () => {
            const hasCard = col.length > 0;
            const index = hasCard ? col.length - 1 : 0;
            handleCardClick({ type: "tableau", column: colIndex }, index, hasCard);
          });
          column.addEventListener("dragover", (event) => {
            event.preventDefault();
            column.classList.add("drop-ready");
          });
          column.addEventListener("dragleave", () => column.classList.remove("drop-ready"));
          column.addEventListener("drop", () => {
            column.classList.remove("drop-ready");
            if (!dragSource) return;
            const selection = dragSource;
            const isStackSelection =
              selection.type === "tableau" && selection.cardIndex < state.tableau[selection.column].length - 1;
            if (isStackSelection) {
              moveStackToTableau(selection, colIndex);
            } else {
              moveSingleCard(getSourceFromSelection(selection), { type: "tableau", index: colIndex });
            }
            dragSource = null;
            clearSelection();
            render();
          });
          if (col.length === 0) {
            const empty = document.createElement("div");
            empty.className = "empty-msg";
            empty.textContent = "비어 있음";
            column.appendChild(empty);
          }
          col.forEach((card, cardIndex) => {
            const cardEl = renderCard(card, { type: "tableau", column: colIndex }, cardIndex);
            cardEl.style.top = `${cardIndex * stackGap}px`;
            column.appendChild(cardEl);
          });
          tableauEl.appendChild(column);
        });
      }

      function renderCard(card, source, cardIndex = 0) {
        const cardEl = document.createElement("div");
        cardEl.className = `card ${card.color}`;
        cardEl.style.backgroundImage = `url("${cardSvg(card)}")`;
        cardEl.innerHTML = `
          <span class="corner">${card.rank}</span>
          <span class="suit">${card.symbol}</span>
        `;
        if (state.selection && isSameSelection(source, cardIndex)) {
          cardEl.classList.add("selected");
        }
        cardEl.addEventListener("click", (event) => {
          event.stopPropagation();
          handleCardClick(source, cardIndex, true);
        });
        cardEl.setAttribute("draggable", "true");
        cardEl.addEventListener("dragstart", (event) => {
          dragSource = { ...source, cardIndex };
          cardEl.classList.add("dragging");
          event.dataTransfer.setData("text/plain", "card");
        });
        cardEl.addEventListener("dragend", () => {
          cardEl.classList.remove("dragging");
          dragSource = null;
        });
        cardEl.addEventListener("dblclick", (event) => {
          event.stopPropagation();
          if (source.type === "tableau") {
            const column = state.tableau[source.column];
            if (column[column.length - 1] !== card) return;
          }
          const index = suits.findIndex((s) => s.name === card.suit);
          const from = getSourceFromSelection({ ...source, cardIndex });
          if (moveSingleCard(from, { type: "foundation", index })) {
            clearSelection();
            render();
          }
        });
        return cardEl;
      }

      function isSameSelection(source, cardIndex) {
        if (!state.selection) return false;
        if (state.selection.type !== source.type) return false;
        if (source.type === "tableau") {
          return state.selection.column === source.column && state.selection.cardIndex === cardIndex;
        }
        return state.selection.index === source.index;
      }

      function updateStatus() {
        moveCountEl.textContent = state.moveCount;
        const freeUsed = state.freeCells.filter(Boolean).length;
        freeCountEl.textContent = `${4 - freeUsed} / 4`;
        const remaining =
          state.tableau.reduce((acc, col) => acc + col.length, 0) +
          state.freeCells.filter(Boolean).length;
        remainingCountEl.textContent = remaining;
      }

      function render() {
        renderTopRow();
        renderTableau();
        updateStatus();
      }

      function newGame() {
        state.freeCells = Array(4).fill(null);
        state.foundations = Array(4).fill(null);
        state.moveCount = 0;
        state.history = [];
        state.selection = null;
        deal();
        render();
      }

      newGameBtn.addEventListener("click", newGame);
      undoBtn.addEventListener("click", () => {
        const snap = state.history.pop();
        if (snap) {
          restore(snap);
          clearSelection();
          render();
        }
      });
      autoBtn.addEventListener("click", () => {
        autoMoveAll();
        clearSelection();
        render();
      });

      newGame();
    </script>
  </body>
</html>
